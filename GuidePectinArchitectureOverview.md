TODO: Out of date.

# A note before we start - building from the data up or the UI down? #
There are a lot of "data up" style frameworks around that aim to produce forms from bean definitions (e.g. rails/grails scaffolding, Tapestry's BeanForm).  This particular method can produce forms very quickly and appears to be great for developer productivity, but typically produces UIs with awful usability that are difficult to change.  The scope for such tools in the world of UI design and construction is typically very narrow.  I see this as an intractable problem since by the very nature of things the UI data model is a superset of the data model typically represented by the underlying bean objects.

Pectin has been designed from the start as a framework for building forms from the UI design down, providing mechanisms for binding to beans (and other data sources) without being constrained by them.  I suspect it could be used quite successfully to build a "beans on forms" layer but it is not limited to that one particular use case.


# Overview of the Pectin approach #
Pectin's approach is to segregate UI code into three basic facets or 'zones of responsibility' if you like, the domain, the presentation model and the View.  The following illustrates.  One of the advantages of this approach is that it brings consistency to developing views.  Behaviour and state is defined by the Presentation Model and the View remains passive.

The following illustrates the chain of data as it passes from the domain to the view.

```
[Domain Data/Services] <-[Adapters]-> [Presentation Model] <-[Bindings]-> [View]
                                               |
                                           [Plugins]
```

**Please note:** The above diagram demonstrates the data path and relationships between the various components of pectin.  It doesn't imply an architectural pattern or an approach to implementing your app or form.  Typically I embed presentation models inside views, those views implement some kind of `Editor` or `Display` interface which then interacts with a supervising controller of some kind.  The view typically delegates most of the `Display` interface to the presentation model.  When creating complex widgets (e.g. an `Address` editor) I tend to create the `AddressModel` separately.  This way other form models can be embedded the address model (and tweak it to their requirements) and pass it to the view which then goes `addressWidget = new AddressWidget(formModel.addressModel)`.

The following outlines the roles of the various bits and pieces.
  1. **Domain Data** - data like the fields of a Customer, Address etc.
  1. **Domain Services** - the things that are used to load/save the domain data and do other server side things.  Pectin doesn't use these currently but I'm hoping I can for async validation.
  1. **Adapters** - The Adapters are responsible for creating `ValueModel`'s from your domain data.  Pectin currently provides `BeanModelProvider`, `AutoCommitBeanModelProvider` and `CopyBeanModelProvider`.  These adapters can either buffer changes (and track dirty state) or pass them directly through.  By using an adaption layer pectin can use data from practically any source.  If ValueModels created by adapter implement auxiliary interfaces these can also be utilised by plugins.
  1. **Presentation Model** - This is your `FormModel`.  It models the data and state required the view.
    * View data includes includes such things as enabled, visible, validation information and anything else you view requires that isn't provided by your domain model.  This additional state is typically managed by plugins or simple value models that hold custom state (e.g. `ValueModel<Boolean> showMoreDetail = ....`)
    * The Presentation Model also typically contains items such as actions/commands (or just plain click handlers) that operate within the scope of the view (e.g. a cancel button, a show/hide button).  This keeps the behaviour out of the view (i.e. no `@UiHandlers`) and you end up with view code like `button.addClickHandler(model.cancelHandler)`.
  1. **Plugins** - allow you to add new language elements to forms (such as `enable(someField).when(someCondition)`.  Plugins have to the opportunity to decorate form fields with additional state and to apply these to widgets during the binding process.
  1. **Bindings** - These are created by pectin using `FormBinder.bind(model.field).to(widget)` style code in your view.  Plugins also generate bindings but this is typically automated during the widget binding process.  Most plugins will also support additional binding helpers like `ValidationBinder.bindValidationOf(model.firstName).to(validationDisplay)`. If the bindings don't meet your requirements you can always hook directly into the ValueChangeEvents generated by the values in the presentation model.
  1. **View** - responsible for binding widgets to the presentation model, laying things out and managing things like tab orders and what not.  It may well implement your 'Display' interface but will ideally delegate most of this to the model (but this all depends on your approach to your applications infrastructure).

# Understanding ValueModels #
Within the Presentation Model pectin makes extensive use of ValueModels.  A value model abstracts the notion of a value (e.g. things like a firstName, postcode or account ballance) by providing access and mutation methods (get/set) and notifications when the value is modified.  Thus all interested parties can modify the value, and all will recieve updates when it is modified by others.  This is what allows pectin to use a declarative style api.

ValueModels come in two basic types, `ValueModel` and `MutableValueModel`.  In the future I may implement an `OccassionllyMutableValueModel` (with a better name of course) for values that can change mutability over time (like values bound via a property path to an underlying object graph).

Please note that while `ValueModel` doesn't provide mutation methods it can still change.  An example would be a value computed using a `Reduce` style function (e.g. such as suming function).  In this case setting the value is meaningless but the value will change if any of the source values update.

## FieldModels are just ValueModels ##
FieldModels are a ValueModel that hold a reference back to the form that created it.  This hook allows plugins to work as they do.  The WidgetBinder uses this to notify the form that a binding has been created, the form then notifies the plugins and they perform additional widget configuration as required.
```
// create our field model 
FieldModel<String> firstName = fieldOfType(String.class).boundTo(beanProvider, "firstName");

// MetadataPlugin.enable(FieldModel<T>) now sets up metadata models in the 
// form and get's ready for callbacks from the binding process. 
enable(firstName).when(...);
```

```
WidgetBinder binder = ...;
TextBox firstName = ...;
// The binder notifies the form which notfies the metadata
// plugin which binds the enabled state to the textbox
binder.bind(model.firstName).to(firstName);
```

## ListModels and ListFieldModels ##
ListModel and ListFieldModel are the ValueModel and FieldModel equivalents for lists.  They fire change events and the mutable versions support add/remove & set operations.

# Using ValueModels outside of Forms #
I also use ValueModels outside of FormModels quite extensively.  They're very useful for modelling state since you don't have to implement things like `HasValueChangeHandlers` all the time.  Once you have a value model you can also derive new models from it using `Conditions` and the like.  For example if have a model object that is lazily loaded (using an RPC method), it could provide a `getState()` method that returns a `ValueModel<State>` which is then used by views etc, e.g.
```
ValueModel<Boolean> disableForm = valueOf(model.getState()).isNot(State.READY));        
```

## ValueHolders ##
Typically the model would use a `ValueHolder` to manage the state and simply call `myState.setValue(LOADING)` as needed.  ValueHolders are just value models that aren't bound to anything.
```
// somewhere in our model object
ValueHolder<State> myState = new ValueHolder<State>(State.VIRGIN);

// then when our model starts loading...
myState.setValue(State.LOADING);

// .. and some time later when we've loaded.
myState.setValue(State.READY);
```

## Showing and Hiding things ##
You can also use the `WidgetBinder` outside of forms to control visibility (and enabledness) of various widgets/elements based on regular value models.
```
widgetBinder
  .show(loadingMessageWidget)
  .when(valueOf(model.getState()).isNot(State.READY)));
widgetBinder
  .show(editorWidget)
  .when(valueOf(model.getState()).is(State.READY)));
```

The above also applies to enabling and disabling things.

## Using External ValueModels in your Forms ##
There will be times when you need to use ValueModels external to the form that are not available when the form is constructed.  In this case you can use a `DelegatingValueModel` in your form and wire it up as normal.  Then whenever you real model becomes available you just configure the delegate.

```
// Use a delegating model instead of the `real thing`
DelegatingValueModel<State> modelState = new DelegatingValueModel<State>();

// we can use the delegating model as per normal to create conditions etc
ValueModel<Boolean> initialised = valueOf(modelState).is(State.READY);
enable(aField).when(initialised)

// then we bind our delegate at some later point in time.
public void setModelThingy(ModelThingy thingy)
{
   // everything will automatically update from here on in.
   modelState.setDelegate(thingy.getState());
} 
```

### A note about memory leaks ###
If your business object is long lived (and your form isn't) then you'll need to remember to clear the delegate when you're done.  Otherwise the business object will reference the delegate and hence your form.  DelegatingValueModels will remove any existing handler when their delegate changes (either to null or to another model) so simplest way to dispose the form is to call `modelState.setDelegate(null)`.



